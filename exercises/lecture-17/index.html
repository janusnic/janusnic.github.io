<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
<script>
"use strict";

// Можна використовувати return без значення. Це призводить до негайного виходу з функції.

// Наприклад:

function showMovie(age) {
  if ( !checkAge(age) ) {
	  return;
  }

alert( "Showing you the movie" ); // (*)
  // ...
}

// Функція з порожнім поверненням або без нього повертає undefined
// Порожнє повернення також те саме, що return undefined:

function doNothing() {
  return;
}
alert( doNothing() === undefined ); // true

Існує інший синтаксис для створення функції, який називається виразом функції.
Це дозволяє створити нову функцію в середині будь-якого виразу. Наприклад:
let sayHi = function() {
  alert( "Hello" );
};
Функціональний вираз - анонімна функція, тобто вона не має імені, яка признаяається  змінній. Наприклад, функція призначена змінній myFunction:
let myFunction = function() {
  // do something
};
Функціональні вирази потрібно визначити перед тим, як їх викликати. Наприклад:
let add = function (a, b) {
  return a + b;
};
console.log(add(1, 2));

Оскільки створення функції відбувається в контексті виразу присвоєння (праворуч від =), це вираз функції.

Зверніть увагу, що після ключового слова функції немає імені. Для виразів функцій дозволено пропускати назву.

Тут ми відразу призначаємо його змінній, тому значення цих зразків коду однакове: «створити функцію та помістити її в змінну sayHi».

У більш складних ситуаціях, з якими ми зіткнемося пізніше, функція може бути створена та негайно викликана або запланована для подальшого виконання, ніде не зберігається, таким чином залишаючись анонімною.
Функція – це значення

Давайте повторимо: як би не була створена функція, функція є значенням. Обидва приклади вище зберігають функцію в змінній sayHi.

Ми навіть можемо роздрукувати це значення за допомогою сповіщення:

function sayHi() {
  alert( "Hello" );
}

alert( sayHi ); // shows the function code
Зверніть увагу, що останній рядок не запускає функцію, оскільки після sayHi немає дужок. Є мови програмування, де будь-яке згадування назви функції викликає її виконання, але JavaScript не такий.

У JavaScript функція є значенням, тому ми можемо розглядати її як значення. Наведений вище код показує його рядкове представлення, яке є вихідним кодом.

Звичайно, функція є особливим значенням у тому сенсі, що ми можемо викликати її як sayHi().
Але це все одно цінність. Тому ми можемо працювати з ним, як і з іншими видами цінностей.
Ми можемо скопіювати функцію в іншу змінну:


function sayHi() {   // (1) create
  alert( "Hello" );
}

let func = sayHi;	// (2) copy

func(); // Hello 	// (3) run the copy (it works)!
sayHi(); // Hello	// 	this still works too (why wouldn't it)

Ось що відбувається вище в деталях:

 	Оголошення функції (1) створює функцію та поміщає її в змінну під назвою sayHi.
 	Рядок (2) копіює його в змінну func. Зверніть увагу ще раз: після sayHi немає дужок. Якби вони були, тоді func = sayHi() записав би результат виклику sayHi() у func, а не в саму функцію sayHi.
 	Тепер функцію можна викликати як sayHi(), так і як func().

Ми також могли б використати вираз функції, щоб оголосити sayHi у першому рядку:

let sayHi = function() { // (1) create
  alert( "Hello" );
};

let func = sayHi;
// ...

Чому в кінці стоїть крапка з комою?

Ви можете запитати, чому вирази функцій мають крапку з комою; в кінці, але оголошення функцій не:

function sayHi() {
  // ...
}

let sayHi = function() {
  // ...
};

Відповідь проста: вираз функції створюється тут як function(…) {…} всередині оператора присвоєння: let sayHi = …;. Крапка з комою ; рекомендується в кінці оператора, це не є частиною синтаксису функції.

Крапка з комою буде там для простішого призначення, наприклад let sayHi = 5;, а також для призначення функції.


Функція зворотного виклику — це функція, яка передається іншій функції як аргумент. Потім функцію зворотного виклику можна викликати всередині викликаної функції, щоб виконати певну дію.
function greeting(name) {
    console.log("Hello " + name);
}

function getUserName(callback) {
    const name = prompt("Enter your name");
    callback(name);
}

getUserName(greeting);



Давайте розглянемо більше прикладів передачі функцій як значень і використання функціональних виразів.

Ми напишемо функцію ask(question, yes, no) з трьома параметрами:

question
  Текст запитання
yes
  Функція для запуску, якщо відповідь «Так»
no
  Функція запуску, якщо відповідь «Ні»


Функція має поставити запитання та, залежно від відповіді користувача, викликати yes() або no():

function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

function showOk() {
  alert( "You agreed." );
}

function showCancel() {
  alert( "You canceled the execution." );
}

// usage: functions showOk, showCancel are passed as arguments to ask
ask("Do you agree?", showOk, showCancel);


На практиці такі функції досить корисні. Основна відмінність між реальним запитом і прикладом вище полягає в тому, що реальні функції використовують більш складні способи взаємодії з користувачем, ніж просте підтвердження. У браузері такі функції зазвичай малюють гарне на вигляд вікно запитань. Але це вже інша історія.

Аргументи showOk і showCancel запиту називаються функціями зворотного виклику або просто зворотними викликами.

Ідея полягає в тому, що ми передаємо функцію та очікуємо, що вона буде «викликана» пізніше, якщо це необхідно. У нашому випадку showOk стає зворотним викликом для відповіді «так», а showCancel — для відповіді «ні».

Ми можемо використовувати вирази функцій, щоб написати еквівалентну, коротшу функцію:

function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

ask(
  "Do you agree?",
  function() { alert("You agreed."); },
  function() { alert("You canceled the execution."); }
);

Тут функції оголошуються прямо всередині виклику ask(...). Вони не мають імені, тому називаються анонімними. Такі функції недоступні за межами запиту (оскільки вони не призначаються змінним), але це саме те, чого ми тут хочемо.

Такий код з’являється в наших сценаріях дуже природно, це в дусі JavaScript.

Функція — це значення, що представляє «дію»
Звичайні значення, такі як рядки або числа, представляють дані.

Функцію можна сприймати як дію.
Ми можемо передавати його між змінними та запускати, коли хочемо.
Вираз функції проти оголошення функції

Давайте сформулюємо ключові відмінності між оголошеннями функцій і виразами.

По-перше, синтаксис: як розрізнити їх у коді.
Оголошення функції: функція, оголошена як окремий оператор у основному потоці коду:

// Function Declaration
function sum(a, b) {
  return a + b;
}

Вираз функції: функція, створена всередині виразу або всередині іншої синтаксичної конструкції. Тут функція створюється в правій частині «виразу присвоєння» =:
	// Function Expression
	let sum = function(a, b) {
  	return a + b;
	};
Більш тонка різниця полягає в тому, коли функція створюється механізмом JavaScript.

Вираз функції створюється, коли виконання досягає його, і його можна використовувати лише з цього моменту.

Після того, як потік виконання перейде до правої сторони призначення, дозвольте sum = функція… – ось, функція створена, і її можна використовувати (призначати, викликати тощо) відтепер.

Оголошення функцій бувають різними.

Оголошення функції можна викликати раніше, ніж воно визначено.
Наприклад, глобальна декларація функції є видимою в усьому сценарії, незалежно від того, де вона знаходиться.
Це через внутрішні алгоритми. Коли JavaScript готується до запуску сценарію, він спочатку шукає в ньому глобальні оголошення функцій і створює функції. Ми можемо розглядати це як «етап ініціалізації».

І після обробки всіх декларацій функцій код виконується. Отже, він має доступ до цих функцій.

Наприклад, це працює:

sayHi("John"); // Hello, John

function sayHi(name) {
  alert( `Hello, ${name}` );
}

Оголошення функції sayHi створюється, коли JavaScript готується до запуску сценарію, і відображається всюди в ньому.

… Якби це був вираз функції, він би не працював:


sayHi("John"); // error!

let sayHi = function(name) {  // (*) no magic any more
  alert( `Hello, ${name}` );
};

Вирази функцій створюються, коли їх досягає виконання. Це станеться лише в рядку (*). Запізно.

Ще одна особливість Оголошень функцій — це їх блокова область.

У строгому режимі, коли оголошення функції знаходиться в блоці коду, воно видно всюди всередині цього блоку. Але не поза ним.

Наприклад, уявімо, що нам потрібно оголосити функцію welcome() залежно від вікової змінної, яку ми отримуємо під час виконання. І потім ми плануємо використовувати його через деякий час.

Якщо ми використовуємо декларацію функції, вона не працюватиме належним чином:

let age = prompt("What is your age?", 18);

// conditionally declare a function
if (age < 18) {

  function welcome() {
	alert("Hello!");
  }

} else {

  function welcome() {
	alert("Greetings!");
  }

}

// ...use it later
welcome(); // Error: welcome is not defined

Це тому, що оголошення функції видно лише всередині блоку коду, у якому воно знаходиться.
Ось інший приклад:

let age = 16; // take 16 as an example

if (age < 18) {
  welcome();           	// \   (runs)
                       	//  |
  function welcome() { 	//  |
	alert("Hello!");   	//  |  Function Declaration is available
  }                    	//  |  everywhere in the block where it's declared
                       	//  |
  welcome();           	// /   (runs)

} else {

  function welcome() {
	alert("Greetings!");
  }
}

// Here we're out of curly braces,
// so we can not see Function Declarations made inside of them.

welcome(); // Error: welcome is not defined
Що ми можемо зробити, щоб зробити привітання видимим за межами if?

Правильним підходом було б використовувати вираз функції та призначити вітання змінній, яка оголошена поза if і має правильну видимість.

Цей код працює за призначенням:

let age = prompt("What is your age?", 18);

let welcome;

if (age < 18) {

  welcome = function() {
	alert("Hello!");
  };

} else {

  welcome = function() {
	alert("Greetings!");
  };

}

welcome(); // ok now

Or we could simplify it even further using a question mark operator ?:

Або ми могли б ще більше спростити це, використовуючи оператор знака питання?:

let age = prompt("What is your age?", 18);

let welcome = (age < 18) ?
  function() { alert("Hello!"); } :
  function() { alert("Greetings!"); };

welcome(); // ok now


Вона називається «функції зі стрілками», тому що виглядає так:

let func = (arg1, arg2, ..., argN) => вираз;

Це створює функцію func, яка приймає аргументи arg1..argN, потім обчислює вираз у правій частині з їх використанням і повертає результат.

Іншими словами, це коротша версія:

let func = function(arg1, arg2, ..., argN) {
  return expression;
};

Let’s see a concrete example:

let sum = (a, b) => a + b;

/* This arrow function is a shorter form of:

let sum = function(a, b) {
  return a + b;
};
*/

alert( sum(1, 2) ); // 3
Як бачите, (a, b) => a + b означає функцію, яка приймає два аргументи з іменами a і b. Після виконання він обчислює вираз a + b і повертає результат.

 	Якщо у нас є тільки один аргумент, то дужки навколо параметрів можна опустити, що робить їх ще коротшими.

 	Наприклад:

let double = n => n * 2;
// roughly the same as: let double = function(n) { return n * 2 }

alert( double(3) ); // 6

Функції зі стрілками можна використовувати так само, як і вирази функцій.

Наприклад, щоб динамічно створити функцію:

	let sayHi = () => alert("Hello!");

	sayHi();

Наприклад, щоб динамічно створити функцію:

let age = prompt("What is your age?", 18);

let welcome = (age < 18) ?
  () => alert('Hello!') :
  () => alert("Greetings!");

welcome();


Функції зі стрілками схожі на звичайні функції, за винятком кількох речей. Перш за все, синтаксис для написання функції зі стрілкою є компактнішим, ніж звичайна функція:
Regular function
function getPrice(cost, quantity) {
	return cost * quantity;
}
Arrow function
(cost, quantity) => cost * quantity;
Спочатку функції стрілок можуть здаватися незнайомими та не дуже читабельними, але це швидко змінюється, коли очі звикають до структури.

Вони дуже зручні для простих однорядкових дій, коли нам просто ліньки писати багато слів.
Функції багаторядкової стрілки

Функції стрілок, які ми бачили досі, були дуже простими. Вони взяли аргументи зліва від =>, обчислили та повернули з ними вираз правої частини.

Іноді нам потрібна більш складна функція з кількома виразами та операторами. У цьому випадку ми можемо взяти їх у фігурні дужки. Основна відмінність полягає в тому, що фігурні дужки вимагають повернення всередині них, щоб повернути значення (так само, як і звичайна функція).

Подобається це:

let sum = (a, b) => {  // the curly brace opens a multiline function
  let result = a + b;
  return result; // if we use curly braces, then we need an explicit "return"
};

alert( sum(1, 2) ); // 3


Функції стрілок також дуже гнучкі. Ви можете використовувати їх як з параметрами, так і без них. Якщо вам потрібен лише один параметр, ви можете використовувати функцію зі стрілкою одним із таких способів:
(day) => 5;
Дужки в цьому випадку необов'язкові.
day => 5;

Якщо вам не потрібні параметри, ви можете скористатися функцією стрілки одним із таких способів:
() => "Candy";
_ => "Candy";


Інша річ, про яку слід пам’ятати, це те, що ви все одно повинні дотримуватися правил блокування коду функцій. Якщо у вас є кілька операторів, які вам потрібно виконати, вам все одно потрібно використовувати фігурні дужки, наприклад:

() => {
	let x = 7;
	let y = -23;
	return x * y;
}

Функції зі стрілками мають інші цікаві особливості.

На даний момент ми вже можемо використовувати функції стрілок для однорядкових дій і зворотних викликів.

Функції стрілок зручні для простих дій, особливо для однорядкових. Вони бувають двох смаків:

Без фігурних дужок: (...args) => вираз – права частина є виразом: функція обчислює його та повертає результат. Дужки можна опустити, якщо є лише один аргумент, напр. n => n*2.
За допомогою фігурних дужок: (...args) => { body } – дужки дозволяють нам писати кілька операторів у функції, але нам потрібен явний результат, щоб щось повернути.



Функція-вираз, що негайно викликається (IIFE - Immediately invoked function expressions) - це ідіома мови програмування, яка створює лексичний обсяг за допомогою визначення області видимості функції. Негайно викликані функціональні вирази можна використовувати для уникнення підйому змінних зсередини блоків, захисту від забруднення глобального середовища та надання публічного доступу до методів, зберігаючи конфіденційність для змінних, визначених у функції. В основі кожного IIFE лежить функція. Наступний фрагмент коду не є дійсним. 
function() {
  // ...
}
Коли аналізатор бачить ключове слово функції на початку оператора, він очікує оголошення функції. Оскільки функція не має назви, вона не відповідає правилам граматики оголошення функції. Таким чином, спроба аналізу не вдається, і ми отримуємо синтаксичну помилку.

Ми якимось чином повинні змусити механізм JavaScript аналізувати функціональний вираз, а не оголошення функції. Якщо ви не впевнені щодо різниці, зверніться до моєї публікації про різні типи визначень функцій у JavaScript.
Насправді трюк досить простий. Ми можемо виправити синтаксичну помилку, помістивши функцію в круглі дужки, що призведе до такого коду:

(function() {
  // ...
})
Як тільки синтаксичний аналізатор зустрічає відкриваючу дужку, він очікує вираз, за яким слідує закриваюча дужка. На відміну від оголошень функцій, функціональні вирази не повинні мати імена, тому наведений вище (у дужках) вираз функції є дійсним фрагментом коду JavaScript.

Єдина частина, яка зараз залишилася, це викликати вираз функції, який ми щойно створили. Наразі функція ніколи не виконується, тому що вона ніколи не викликається, і без її призначення ні до чого неможливо отримати її пізніше. 
Ми додамо пару круглих дужок (і крапку з комою, для хорошої міри) у кінці:

(function() {
  // ...
})();

Проте деяким людям, як-от Дугласу Крокфорду, не подобається естетика звисаючої пари дужок, тому вони розміщують їх у обгортці:


(function() {
  // ...
}());

Обидва підходи є ідеальними (і семантично еквівалентними) реалізаціями негайно викликаного виразу функції, тому просто виберіть той, який вам більше подобається.

Запобігання проблемам під час об’єднання файлів

Іноді ви можете зустріти IIFE, який має початкову крапку з комою перед відкриваючою обертальною дужкою:
;(function() {
  // ...
})();

Ця захисна крапка з комою існує для запобігання проблемам, які можуть виникнути під час об’єднання двох файлів JavaScript. Уявіть, що перший файл містить такий код:

var foo = bar

Зауважте, що в операторі оголошення змінної немає крапки з комою. Якби другий файл JavaScript містив IIFE без крапки з комою на початку, об’єднаний результат був би таким:


var foo = bar
(function() {
  // ...
})();

Це може виглядати як призначення панелі ідентифікатора змінній foo з наступним IIFE, але це не так. Натомість bar намагається викликати як функцію, яка передає іншу функцію як аргумент. Видалення розриву рядка після смуги має зробити код більш зрозумілим:

var foo = bar(function() {
  // ...
})();

Початкова крапка з комою запобігає цьому небажаному виклику функції:

var foo = bar
;(function() {
  // ...
})();

Функції зі стрілками замість виразів функцій

У ECMAScript 2015 JavaScript було розширено синтаксисом функції зі стрілками для визначення функцій. Як і вирази функцій, функції зі стрілками є виразами, а не операторами. Це означає, що ми можемо створити функцію зі стрілкою, яка негайно викликається, якщо хочемо:

(function() {
  // ...
})();
Або розмістити дужки у обгортці:
(function() {
  // ...
}());

Також можна створити функцію зі стрілкою, яка негайно викликається:


(() => {
  // ...
})();

Оператор void використовується для отримання невизначеного примітивного значення, зазвичай використовуючи void(0) (що еквівалентно void 0). У цих випадках можна використовувати глобальну змінну undefined.

Слід враховувати пріоритет оператора void:

void 2 === "2"; // (void 2) === '2', returns false
void (2 === "2"); // void (2 === '2'), returns undefined

Для того, щоб функція була розібрана як вираз, ключове слово функції має з’являтися в позиції, яка приймає лише вирази, а не оператори. Цього можна досягти, додавши до ключового слова унарний оператор, який приймає лише вирази як операнди. 

Виклик функції має вищий пріоритет, ніж унарні оператори, тому він буде виконано першим. Його повертане значення (яке майже завжди невизначене) буде передано унарному оператору, а потім негайно відкинуто.

З усіх унарних операторів void пропонує найкращу семантику, оскільки він чітко сигналізує, що значення, що повертається викликом функції, слід відкинути.

void function () {
  console.log("Executed!");
}();

// Logs "Executed!"


// який тип отримає змінна message у нвступному коді:

let greeting = 'Hello';
function greet(name) {
  return greeting + ' ' + name;
}
console.log(greet('Paul')); // Hello Paul

function greet(greeting, name) {
  return greeting + ' ' + name;
}
console.log(greet('Howdy', 'Paul')); // Howdy Paul

Тепер ми нічого не можемо зробити, щоб функція greet повертала інший результат, якщо ми не змінимо один із її вхідних аргументів.

Рекурсивна функція — це функція, яка викликає сама себе десь у тілі функції. Нижче наведено базовий приклад рекурсивної функції.

function recursiveFunc() {
  // some code here...
  recursiveFunc()
}

Як бачите, функція recursiveFunc викликає саму себе в тілі функції. Він буде повторювати виклик, доки не буде досягнуто бажаного результату.

Отже, як повідомити функції, коли припинити виклик самої себе? Ви робите це за допомогою базової умови.


Три частини рекурсивної функції
Кожного разу, коли ви пишете рекурсивну функцію, мають бути присутні три елементи. Вони є:


The function definition.
The base condition.
The recursive call.

Якщо ці три елементи відсутні, ваша рекурсивна функція працюватиме не так, як ви очікуєте. Давайте розглянемо кожен з них докладніше.

Як визначити рекурсивну функцію
Ви визначаєте рекурсивну функцію так само, як і звичайні функції JavaScript.

function recursiveFunc() {
  // some code here...
}

function recursiveFunc() {
  if(base condition) {
	// stops recursion if condition is met
  }
  // else recursion continues
  recurse();
}

function doSomething(action) {
  console.log(`I am ${action}.`)
  doSomething(action)
}
doSomething("running")

function doSomething(n) {
  if(n === 0) {
	console.log("TASK COMPLETED!")
	return
  }
  console.log("I'm doing something.")
  doSomething(n - 1)
}
doSomething(3)









</script>
</body>
</html>