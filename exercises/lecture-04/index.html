<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>lecture 04</title>
</head>
<body>
    
Селектор елементів вибирає елементи на основі назви тегу. Селектор елемента застосовує формат для усіх елементів даного типу на веб-сторінці. Наприклад, 

задає загальний стиль форматування усіх заголовків h1.
H1 {
   font-size: 2.2rem;
}

задає загальний стиль форматування усіх p.

p {
   font-family: arial, helvetica, sans-serif;
}

Щоб вибрати елементи з їх іменами класів, використовуйте . безпосередньо перед назвою класу. Селектори класів дозволяють задавати стилі для одного чи більше елементів з однаковим іменем класу. 

Наприклад, для створення заголовка з класом .h2 необхідно добавитти атрибут class зі значенням .h2 до початкового тегу <h2> та задати стилі для вказаного класу. 

Стилі, що створені за допомогою класу, можна застосувати до інших елементів
 
.h2 {
    font-size: 1.9rem;
}

Оскільки ідентифікатор елемента є унікальним на сторінці, селектор ідентифікатора вибирає один елемент із певним атрибутом ідентифікатора. Щоб вибрати елемент із його конкретним ідентифікатором, використовуйте символ # перед назвою ідентифікатора.

#main {
     width: 100%;
     color: #555;
}

Селектор ідентифікатора форматує один конкретний елемент. Ідентифікатор id має бути унікальним на веб-странице.

<main role="main" class="container" id='main'>
Lorem ipsum dolor sit amet consectetur adipisicing elit. Accusantium saepe placeat quisquam, eveniet aliquam ipsum amet cupiditate repudiandae obcaecati, impedit aperiam. 
</main>

Універсальний селектор виділяє всі елементи на сторінці. Щоб виділити всі елементи веб-сторінки, просто використовуйте знак *.

For example:

* {
  margin: 0;
  padding: 0;
}

Нащадок - це просто елемент, який знаходиться всередині іншого елемента. Наприклад:
<div>
    <h1>This is a heading. Тут h1 є нащадком div.</h1>
</div>

Комбінатор нащадків (descendent combinator) вибирає елементи, які є нащадками зазначеного батьківського елемента. Ключова ідея тут полягає в тому, що не треба турбуватися про те, наскільки глибоко вкладені елементи-нащадки всередині батьківського. Незалежно від того, чи знаходяться вони безпосередньо в батьківській системі, чи на кількох рівнях, можна вибрати їх всі. Наприклад:

<section>
    <p>This is a paragraph.</p>
    <div>
         <p>This is another paragraph.</p>
    </div>
</section>

Щоб вибрати нащадка, напишіть назву тегу, атрибут класу або атрибут id батьківського елемента, а після пробілу напишіть ім’я нащадка.
    section p {
     font-size: 20px;
    }
    
Дочірній комбінатор вибирає елементи, які є прямими дочірніми елементами зазначеного батьківського елемента. Щоб вибрати прямий дочірній елемент, використовуйте знак > між батьківським і дочірнім елементами.

<ul>
    <li>HTML</li>
    <li>CSS</li>
</ul>

Дочірній комбінатор вибирає елементи, які є прямими дочірніми елементами зазначеного батьківського елемента. Щоб вибрати прямий дочірній елемент, використовуйте знак > між батьківським і дочірнім елементами.

ul > li {
    font-weight: bold;
}

Комбінатор наступного рівня (сусіднього брата - Next-sibling  + ) вибирає елемент, який є безпосереднім братом зазначеного елемента, і між ними не повинно бути інших елементів .

/* Пробіл навкруг комбінатора + не є обов'язковим, проте рекомендується. */
    former_element + target_element { style properties }
    
    li:first-of-type + li {
         color: red;
    }
    
    <ul>
     <li>One</li>
     <li>Two!</li>
     <li>Three</li>
    </ul>
    
    
Загальний однорідний комбінатор вибирає однорідні елементи, які мають один і той самий батьківський елемент і розташовані після зазначеного елемента. Цей комбінатор не вимагає, щоб вибраний елемент безпосередньо передував зазначеному елементу. Загальний однорідний комбінатор представлений символом ~.
    <p>I'm sibling paragraph of div.</p>
    <div>
        <p>This is a paragraph inside a div.</p>
        <p>This is another paragraph inside a div.</p>
    </div>
    <p>I'm sibling paragraph of div.</p>
    <h6>I'm sibling heading of div.</h6>
    <p>I'm sibling paragraph of div.</p>
 Комбінатор не змінить стиль елемента p, який стоїть перед елементом div, тому що загальний однорідний комбінатор вибирає однорідні елементи, які йдуть після зазначеного елемента, а тут вказаний елемент div.
       div ~ p {
            color: red;
        }
Селектор атрибутів ([attr=value]) зіставляє елементи на основі їхнього атрибута та значення.

        input[type="text"] {
             border: 1px solid green;
         }
  
Стилізує всі поля введення тексту з green рамкою. Це корисно для стилізації певних елементів форми або елементів з унікальними атрибутами даних.

Селектор групування (,) дозволяє застосовувати однакові стилі до кількох елементів.

h1, h2, h3 {
    font-family:  'Arial', sans-serif;
}
  
Встановлює узгоджений шрифт на трьох рівнях заголовків. Підхід, що економить час, коли різні елементи мають спільний набір стилів.
  
CSS має цілу низку різних форматів кольорів: шістнадцяткові коди, rgb(), hsl(), lch(), список можна продовжувати!

Специфікація CSS визначає 140 імен кольорів, з них 17 стандартних: aqua, black, blue, fuchsia, gray, green, lime, maroon, navy, olive, orange, purple, red, silver, teal, white, yellow.

Кольори можна задавати за допомогою шістнадцятирічного коду: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. Перед числом встановлюють символ #. Існує скорочена форма вигляду #rgb. 

Можна визначати колір у десятковій системі числення за допомогою функції RGB. 

HTML містить 140 іменованих кольорів. Це спеціальні значення ключових слів, наприклад dodgerblue, hotpink і tomato:
  body {
    color: tomato;
  }

Іменовані кольори чудово підходять, коли вам потрібен колір-заповнювач. Наприклад, якщо ви створюєте прототип і потребуєте тимчасових значень, або якщо ви пишете навчальний контент. З точки зору зручності читання, ніщо не зрівняється з кольором: червоним.

Ми зазвичай не використовуємо іменовані кольори у виробничих програмах. 140 кольорів просто недостатньо - це навіть менше, ніж 8-бітна палітра кольорів, доступна на оригінальній консолі NES!

Як і більшість кольорових форматів, rgb є акронімом. Це означає червоний зелений синій.

body {
    color: rgb(255 0 0);
}

З усіх кольорових форматів rgb є найменш абстрактним. Дисплей комп’ютера/телефону – це набір мільйонів крихітних червоних, зелених і синіх світлодіодів, зібраних у пікселі. Кожне значення - червоне, зелене, синє - називається каналом. Кожен канал змінюється від 0 до 255. Змішуючи ці канали від 0 до 255, можна створити понад 16 мільйонів різних кольорів.

rgb (255, 255, 255) - rgba (255, 255, 255,1) - #FFFFFF або #FFF - white
rgb (000, 000, 000) - rgba (000, 000, 000,1) - #000000 або #000   - black
rgb (255, 000, 000) - rgba (255, 000, 000,1) - #FF0000 або #F00  - red
rgb (000, 255, 000) - rgba (000, 255, 000,1) - #00FF00 або #0F0  - green
rgb (000, 000, 255) - rgba (000, 000, 255,1) - #0000FF або #00F  - blue
Цікава особливість кольору RGB полягає в тому, що він заснований на фізиці світла. Ми можемо змішувати червоне, зелене та синє світло, щоб створити будь-який колір.


Для напівпрозорих кольорів раніше використали окрему функцію rgba:
       .translucent-box {
           background: rgba(255, 0, 0, 0.5);
       }

Альфа-канал варіюється від 0 (повністю невидимий) до 1 (повністю непрозорий). Все, що знаходиться між ними, створює напівпрозорий колір.
Новий спосіб визначення прозорості такий:
  .translucent-box {
           /* Try changing “0.5” to something else: */
           background: rgb(255 0 0 / 0.5);
       }
Слеш має бути роздільником. 

Це, мабуть, найпоширеніший колірний формат в Інтернеті. Це виглядає так:
       body {
           color: #FF0000;
       }
Ось як це працює: 6-значний шістнадцятковий код містить три 2-значні значення, по одному для кожного каналу (червоний/зелений/синій). Замість використання 10-значної десяткової системи він використовує 16-значну шістнадцяткову систему.
По суті, шістнадцяткові коди такі ж, як значення RGB. В обох випадках ми надаємо значення для червоного, зеленого та синього кольорів.

У десятковій системі двозначне число може містити 100 можливих значень (10 × 10). У шістнадцятковій формі загальне число дорівнює 256 (16 × 16). І тому це дійсно схоже на rgb(), де ми вказуємо значення від 0 до 255 для кожного каналу R/G/B.
HSL - Hue, Saturate, Lightness. 
Hue - значення кольору на кольоровому колі, встановлюється у градусах. 0° відповідає червоному, 120° - зеленому, 240°- блакитному. Значення змінюється від 0 до 359.
Saturate - інтенсивність кольлру, вимірюється у відсотках. 0% означає відсутність кольору та відтінок сірого, 100% максимальне значення.

Lightness встановлюється у відсотках. Малі значення роблять колір темним, великі -  світлим, 0% та 100% відповідають чорному і білому.
       .box {
           background-color: hsl(0deg 100% 50%);
       }
У HSL Lightness - це шкала між чорним і білим. Світлота 0% - це завжди чорний колір, Світлота 100% - завжди білий. Якщо ми хочемо отримати яскравий, насичений колір, нам слід зафіксувати Lightness на рівні 50%, що знаходиться посередині між чорним і білим.

Можна використовувати властивість background-color, щоб заповнити фон кольором.

.container {
/* we'll change values 👇  here */
   background-color :  red;
}

CSS Unit - це стандарт вимірювання, який використовується в CSS для вираження розміру властивості певного елемента. Одиниця - це міра для вираження кількості або розміру іншої речі.
CSS має два основних типи одиниць: абсолютну та відносну.
Ви можете використовувати як абсолютні, так і відносні одиниці вимірювання. Однак, якщо ви дбаєте про доступність, найкраще зробити одиниці відносної довжини основним вибором.

Одиниці абсолютної довжини є фіксованими еталонами вимірювання.
Розмір речей, виражений в будь-якій з абсолютних одиниць довжини, ніколи не зміниться, незалежно від середовища, що використовується для їх відображення. Таким чином, вони найкраще працюють із результатами друку.

Приклади одиниць CSS абсолютної довжини
cm     (Centimeter - сантиметр)    1cm = 96px/2.54 = 37.795px
mm    (Millimeter - міліметр)    1mm = 1cm / 10 
Q       (Quarter millimeters - чверть міліметра)    1Q = 1cm / 40
in       (Inch - дюйм)    1in = 96px = 2.54cm 
pc      (Pica - піка)    1pc = 1in / 6 
pt       (Point - пункт)    1pt = 1in  / 72 
px      Pixel   1px = 1in / 96 

Абсолютні одиниці мають працювати правильно лише при друкуванні. Співвідношення між абсолютними одиницями: 1in = 2.54cm = 25.4mm = 72pt = 6pc. 
Піксель (px) — єдина абсолютна одиниця, яка зазвичай використовується для веб-проектів.
На Macintosh 1984 року 1 піксель у (гіпотетичному) браузері дорівнював би одному фізичному пікселю ЕЛТ-монітора. Зараз наші дисплеї використовують набагато вищу щільність пікселів, тому 1 піксель відображається за допомогою 2 або більше фізичних пікселів - це називається HiDPI (або сітківка для користувачів Apple). Усі постачальники дисплеїв використовують різну щільність і розміри. 

Специфікація CSS W3C вирішує цю проблему дуже класним і незвичайним способом:
Еталонний піксель – це кут огляду одного пікселя на пристрої з щільністю пікселів 96 dpi і відстанню від зчитувача на відстані витягнутої руки. Таким чином, для номінальної довжини 28 дюймів кут зору становить близько 0,0213 градуса. Таким чином, для читання на відстані витягнутої руки 1 піксель відповідає приблизно 0,26 мм (1/96 дюйма).

Це робить px напіввідносною одиницею. Відносно розміру вашого дисплея та щільності пікселів. В CSS  px - це єдина «абсолютна» одиниця, яка використовується під час компонування на екранах. 

Відносні одиниці довжини шрифту створюють значення. які залежать від розміру шрифту батьківського елемента. Це значення на основі множника, наприклад 1,5em == 1,5 × $fontSize В CSS одиницею за замовчуванням є піксель (px). Піксел - це елементарна точка, що відображається монітором чи смартфоном. Розмір пікселя залежить від спроможності пристрою та його технічних характеристик.  CSS вимагає, щоб 1px точно дорівнював 1/96 дюйма під час друку. 

Відсоткові одиниці - це відсоток від розміру елемента пращура. 
Для шрифтів властивість font-size: 100% встановлює розмір тексту 100% від базового розміру шрифта у браузері. Більшість браузеров за замовчуванням використовує базовий розмір шрифта 16px. 

Рекомендується встановлювати базовий розмір шрифта у 100% для кореневого елементу html та використовувати відносні одиниці для обробки усіх інших правил визначення розміру шрифта.
Розміри відступів, ширини та інше, розраховуються відносно ширини елемента. 
body { font-size: 71.42857%; }

em - це одиниця вимірювання відносно розміру шрифту поточного елемента. Це друкарська одиниця з епохи металевих шрифтів і спочатку вказувала на ширину великої літери M (звідки й назва). Один em дорівнює розміру шрифту, тому за замовчуванням він дорівнює 1rem, який за замовчуванням становить 16 пікселів.
У наступному прикладі .box буде відображено з відступом 18px, оскільки 1em є відносним до неявного розміру шрифту:
       .box {
           font-size: 18px;
           padding: 1em;
       }
У наступному прикладі всі елементи списку буде відображено з лівим полем 3 × 12px = 36px, оскільки font-size: 12px; є найближчим, успадкованим оголошенням розміру шрифту.
       ul {
           font-size: 12px;
       }
       ul li {
           margin-left: 3em;
       }
Одиниця rem масштабує елемент відносно розміру шрифту кореневого елемента html. Значення rem за замовчуванням становить 16 пікселів.
Приклад: 3rem означає тричі поточний розмір шрифту кореневого елемента html.
Різниця між одиницями em і rem полягає в тому, що em масштабує елемент відносно розміру шрифту батьківського елемента.
Одиниця rem масштабує елемент відносно розміру шрифту кореневого елемента.
        
rem не зміниться незалежно від того, наскільки глибоко він вкладений, тому для сталого інтервалу між елементами/навколо них це надійний вибір.
Це також найкраще вимірювання розміру шрифту.

Одиниця відсотка (%) масштабує елемент відносно розміру батьківського елемента.

Приклад 1: Розмір шрифту, встановлений на 2%, означає «відрегулювати розмір мого шрифту до двох відсотків поточного розміру шрифту мого батьківського елемента».

Приклад 2: Ширина зображення, встановлена на 50%, означає «відрегулювати мою ширину до п’ятдесяти відсотків поточної ширини мого батьківського елемента». % — символ одиниці «відсотка».
        
Різниця між em і відсотковою одиницею полягає в тому, що em масштабує елемент шляхом множення розміру шрифту батьківського елемента на число. Однак % масштабує елемент шляхом множення розміру батьківського елемента на відсоток.
        
Є ще дві відносні одиниці, які ви ніколи не побачите в реальних проектах: ex і ch.

Люди рідко використовують ex.
Одиниця ex дорівнює висоті малої літери х батьківського елемента.
ex є відносною до поточної висоти x шрифту. 
        
Одиниця ch дорівнює ширині символу 0(нуль) у наборі сімейства шрифтів..
CSS має 4 одиниці виміру на основі області перегляду: vh, vw, vmin та vmax.

Довжина області перегляду (vh). Значення 1vh = 1% від довжини області перегляду.

Ширина області перегляду (vw). Значення 1vw = 1% ширини області перегляду.

Мінімальна сторона області перегляду (vmin). 

Максимальна сторона області перегляду (vmax). 

Одиниці Viewport ідеально підходять для:
        утримання елемента в межах видимої області
        створення пропорційних, чуйних елементів
        впливу на видимість кількох елементів
        

Ширина вікна перегляду (vw) масштабує елемент відносно 1% ширини вікна браузера.

Якщо ширина вікна перегляду становить 35 см, 1vw означатиме 0,35 см, тобто 1% від 35 см. vw - символ одиниці вимірювання «ширина вікна перегляду».

Висота вікна перегляду (vh) масштабує елемент відносно 1% висоти вікна браузера.

Якщо розмір вікна перегляду становить 19 см у висоту, 1vh означатиме 0,19 см, тобто 1% від 19 см. vh - символ одиниці «висоти вікна перегляду».

Мінімальна область перегляду (vmin) масштабує елемент відносно мінімального розміру між шириною та висотою вікна перегляду. vmin - це символ одиниці мінімального вікна перегляду.

Максимум вікна перегляду (vmax) масштабує елемент відносно максимального розміру між шириною та висотою вікна перегляду.  vmax - це символ одиниці максимум вікна перегляду.

</body>
</html>